// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WALL_MJ2_SCHEMA_H_
#define FLATBUFFERS_GENERATED_WALL_MJ2_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace mj2 {
namespace schema {

struct Comment;

struct Wall;

struct Comment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RLTTIME = 4,
    VT_ABSTIME = 6,
    VT_USERID = 8,
    VT_CONTENT = 10
  };
  int32_t rltTime() const {
    return GetField<int32_t>(VT_RLTTIME, 0);
  }
  int64_t absTime() const {
    return GetField<int64_t>(VT_ABSTIME, 0);
  }
  const flatbuffers::String *userId() const {
    return GetPointer<const flatbuffers::String *>(VT_USERID);
  }
  const flatbuffers::String *content() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RLTTIME) &&
           VerifyField<int64_t>(verifier, VT_ABSTIME) &&
           VerifyOffset(verifier, VT_USERID) &&
           verifier.Verify(userId()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.Verify(content()) &&
           verifier.EndTable();
  }
};

struct CommentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rltTime(int32_t rltTime) {
    fbb_.AddElement<int32_t>(Comment::VT_RLTTIME, rltTime, 0);
  }
  void add_absTime(int64_t absTime) {
    fbb_.AddElement<int64_t>(Comment::VT_ABSTIME, absTime, 0);
  }
  void add_userId(flatbuffers::Offset<flatbuffers::String> userId) {
    fbb_.AddOffset(Comment::VT_USERID, userId);
  }
  void add_content(flatbuffers::Offset<flatbuffers::String> content) {
    fbb_.AddOffset(Comment::VT_CONTENT, content);
  }
  CommentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommentBuilder &operator=(const CommentBuilder &);
  flatbuffers::Offset<Comment> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Comment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Comment> CreateComment(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rltTime = 0,
    int64_t absTime = 0,
    flatbuffers::Offset<flatbuffers::String> userId = 0,
    flatbuffers::Offset<flatbuffers::String> content = 0) {
  CommentBuilder builder_(_fbb);
  builder_.add_absTime(absTime);
  builder_.add_content(content);
  builder_.add_userId(userId);
  builder_.add_rltTime(rltTime);
  return builder_.Finish();
}

inline flatbuffers::Offset<Comment> CreateCommentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rltTime = 0,
    int64_t absTime = 0,
    const char *userId = nullptr,
    const char *content = nullptr) {
  return mj2::schema::CreateComment(
      _fbb,
      rltTime,
      absTime,
      userId ? _fbb.CreateString(userId) : 0,
      content ? _fbb.CreateString(content) : 0);
}

struct Wall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MOVIEID = 4,
    VT_COMMENTS = 6
  };
  const flatbuffers::String *movieId() const {
    return GetPointer<const flatbuffers::String *>(VT_MOVIEID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Comment>> *comments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Comment>> *>(VT_COMMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MOVIEID) &&
           verifier.Verify(movieId()) &&
           VerifyOffset(verifier, VT_COMMENTS) &&
           verifier.Verify(comments()) &&
           verifier.VerifyVectorOfTables(comments()) &&
           verifier.EndTable();
  }
};

struct WallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_movieId(flatbuffers::Offset<flatbuffers::String> movieId) {
    fbb_.AddOffset(Wall::VT_MOVIEID, movieId);
  }
  void add_comments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Comment>>> comments) {
    fbb_.AddOffset(Wall::VT_COMMENTS, comments);
  }
  WallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WallBuilder &operator=(const WallBuilder &);
  flatbuffers::Offset<Wall> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Wall>(end);
    return o;
  }
};

inline flatbuffers::Offset<Wall> CreateWall(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> movieId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Comment>>> comments = 0) {
  WallBuilder builder_(_fbb);
  builder_.add_comments(comments);
  builder_.add_movieId(movieId);
  return builder_.Finish();
}

inline flatbuffers::Offset<Wall> CreateWallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *movieId = nullptr,
    const std::vector<flatbuffers::Offset<Comment>> *comments = nullptr) {
  return mj2::schema::CreateWall(
      _fbb,
      movieId ? _fbb.CreateString(movieId) : 0,
      comments ? _fbb.CreateVector<flatbuffers::Offset<Comment>>(*comments) : 0);
}

inline const mj2::schema::Wall *GetWall(const void *buf) {
  return flatbuffers::GetRoot<mj2::schema::Wall>(buf);
}

inline bool VerifyWallBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mj2::schema::Wall>(nullptr);
}

inline void FinishWallBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mj2::schema::Wall> root) {
  fbb.Finish(root);
}

}  // namespace schema
}  // namespace mj2

#endif  // FLATBUFFERS_GENERATED_WALL_MJ2_SCHEMA_H_
